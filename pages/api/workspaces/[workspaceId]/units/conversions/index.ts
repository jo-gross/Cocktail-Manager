import { withHttpMethods } from '@middleware/api/handleMethods';
import HTTPMethod from 'http-method-enum';
import { withWorkspacePermission } from '@middleware/api/authenticationMiddleware';
import { Prisma, Role, Unit, UnitConversion } from '@generated/prisma/client';
import prisma from '../../../../../../prisma/prisma';
import { Graph, shortestPath } from 'graph-data-structure';
import UnitConversionCreateInput = Prisma.UnitConversionCreateInput;

export default withHttpMethods({
  [HTTPMethod.GET]: withWorkspacePermission([Role.USER], async (req, res, user, workspace) => {
    const unitConversions = await prisma.unitConversion.findMany({ where: { workspaceId: workspace.id } });
    return res.json({ data: unitConversions });
  }),
  [HTTPMethod.POST]: withWorkspacePermission([Role.ADMIN], async (req, res, user, workspace) => {
    const { fromUnitId, toUnitId, factor } = req.body;
    const input: UnitConversionCreateInput = {
      fromUnit: { connect: { id: fromUnitId } },
      toUnit: { connect: { id: toUnitId } },
      factor: factor,
      workspace: {
        connect: {
          id: workspace.id,
        },
      },
    };

    const unitConversion = await prisma.unitConversion.create({ data: input });
    await prisma.unitConversion.create({
      data: {
        fromUnit: { connect: { id: toUnitId } },
        toUnit: { connect: { id: fromUnitId } },
        factor: 1 / factor,
        autoGenerated: true,
        workspace: { connect: { id: workspace.id } },
      },
    });

    return res.json({ data: await regenerateUnitConversions(workspace.id) });
  }),
});

export async function regenerateUnitConversions(workspaceId: string): Promise<UnitConversion[]> {
  // Recalculate all unit conversions
  await prisma.unitConversion.deleteMany({
    where: {
      workspaceId: workspaceId,
      AND: {
        autoGenerated: true,
      },
    },
  });

  const nodes: Unit[] = await prisma.unit.findMany({ where: { workspaceId: workspaceId } });
  const paths: UnitConversion[] = await prisma.unitConversion.findMany({ where: { workspaceId: workspaceId } });

  const graph = new Graph<string>();
  nodes.forEach((node) => graph.addNode(node.id));
  paths.forEach((path) => {
    graph.addEdge(path.fromUnitId, path.toUnitId);
    graph.addEdge(path.toUnitId, path.fromUnitId);
  });

  function generatePairCombinations(units: string[]): [string, string][] {
    const combinations: [string, string][] = [];

    for (let i = 0; i < units.length; i++) {
      for (let j = i + 1; j < units.length; j++) {
        combinations.push([units[i], units[j]]);
        combinations.push([units[j], units[i]]);
      }
    }

    return combinations;
  }

  const combinations = generatePairCombinations(nodes.map((node) => node.id));

  const allConnections: string[][] = [];

  combinations.forEach((combination) => {
    try {
      const path = shortestPath(graph, combination[0], combination[1]);
      // const path = graph.shortestPath(combination[0], combination[1]);
      allConnections.push(path.nodes);
    } catch (e) {}
  });

  const allConversions: UnitConversion[] = paths;

  for (const connection of allConnections) {
    const fromOrig = connection[0];
    let to = connection[1];
    let factor = 1;
    for (let i = 0; i < connection.length - 1; i++) {
      const from = connection[i];
      to = connection[i + 1];
      const foundFactor =
        paths.find((path) => path.fromUnitId === from && path.toUnitId === to)?.factor ||
        1 / (paths.find((path) => path.fromUnitId === to && path.toUnitId === from)?.factor ?? 1) ||
        1 ||
        1;
      factor *= foundFactor;
    }
    if (!paths.find((path) => path.fromUnitId === fromOrig && path.toUnitId === to)) {
      allConversions.push(
        await prisma.unitConversion.create({
          data: {
            fromUnit: { connect: { id: fromOrig } },
            toUnit: { connect: { id: to } },
            factor: factor,
            autoGenerated: true,
            workspace: { connect: { id: workspaceId } },
          },
        }),
      );
    }
    if (!paths.find((path) => path.fromUnitId === to && path.toUnitId === fromOrig)) {
      allConversions.push(
        await prisma.unitConversion.create({
          data: {
            fromUnit: { connect: { id: to } },
            toUnit: { connect: { id: fromOrig } },
            factor: 1 / factor,
            autoGenerated: true,
            workspace: { connect: { id: workspaceId } },
          },
        }),
      );
    }
  }

  return allConversions;
}
